import pymrio
import pandas as pd
import numpy as np

##################################################################################################################################################################################################################

'''Load tables from original exiobase 2011 parsed files
   that were downloaded and parsed from the EXIOBASE Zenodo repository.
   IOT_2011_pxp 2011.zip file from version 3.8.1 of EXIOBASE '''

##################################################################################################################################################################################################################

exiobase3 = pymrio.load_all('C:/Users/Cillian/PycharmProjects/MRIO_project_Ver_01/Exiobase3 folder/Exiobase3 coefficent tables - original')  #load original tables parsed from Exiobase pxp 2011
S = pd.DataFrame(exiobase3.satellite.S)
Y = pd.DataFrame(exiobase3.Y)

##################################################################################################################################################################################################################

'''Segregating the household consumption category from the Y tables'''

##################################################################################################################################################################################################################
idx = pd.IndexSlice             #Slicing of multi index columns for separating out multiindex columns
Y = pd.DataFrame(Y.loc[:,idx[:,'Final consumption expenditure by households']])  #Seggregating final consumer household demand
print(Y)
exiobase3.Y = pd.DataFrame(Y)  #New Y tables in terms of 'Final consumption by households only'

##################################################################################################################################################################################################################


'''Segregating required stressors from S tables. Segregation is completed via index referencing of original tables.
   Details on stressors and S table row index, see Appendix F in project literature'''

##################################################################################################################################################################################################################


land_stressors = pd.DataFrame(S.iloc[[446,447,448,449,450,451,452,453,454,455,456,457,458,459, 461,462,463,464,465],:])  #Seperation of land use categories using indexing. Rows obtained from csv file
water_stressors = pd.DataFrame(S.iloc[923:1026])  #Blue water consumption stressor rows
climate_change_stressors = pd.DataFrame(S.iloc[[23,24,25,67,68,69,70,71,72,73,74,92,93,426,427,429,435,437,438]]) #Climate change stressor rows
eutrophication_stressors = pd.DataFrame(S.iloc[[432,433,434,440,443]]) #Marine and Fresh eutrophication

#Aggregation of exiobase land use categories to LC-IMPACT categories

Annual_crop_df = pd.DataFrame(land_stressors.iloc[[0,1,2,3,4,5,6,7,8,9,10,12],:]).sum(0) #Aggregation of the annual crop categories in exiobase to the singular LC-IMPACT category for Land Use
print(Annual_crop_df)
Annual_crop_df = pd.DataFrame(Annual_crop_df).T #As python outputs a column vector for a summation operation, the transpose function T is used to return the annual crop dataframe to it's original Dataframe index/column set up with countries and products as the column index and stressor as the row index.
Permanent_crop_df = pd.DataFrame(land_stressors.iloc[[11],:]).sum(0)  #Aggregation of permanent crop categories to LC-Impact land category
Permanent_crop_df = pd.DataFrame(Permanent_crop_df).T   #Transposing to original Dataframe layout.
Pasture_crop_df = pd.DataFrame(land_stressors.iloc[[14,15,16],:]).sum(0) #Aggregation of Pasture crop land use categories
print(Annual_crop_df)
Pasture_crop_df = pd.DataFrame(Pasture_crop_df).T
Urban_df = pd.DataFrame(land_stressors.iloc[[17],:]).sum(0) #Aggregation of Urban land use categories
Urban_df = pd.DataFrame(Urban_df).T
Intensive_forestry_df = pd.DataFrame(land_stressors.iloc[[13],:]).sum(0) #Aggregation of Intensive forestry land use stresors to LC-Impact category
Intensive_forestry_df = pd.DataFrame(Intensive_forestry_df).T
Extensive_forestry_df = pd.DataFrame(land_stressors.iloc[[18],:]).sum(0) #Aggregation of Intensive forestry land use stresors to LC-Impact
Extensive_forestry_df = pd.DataFrame(Extensive_forestry_df).T

#Re-creating a combined dataframe for the aggregated land use stressors

Land_aggregated_df = Annual_crop_df
landuse_list = (Permanent_crop_df,Pasture_crop_df,Urban_df,Extensive_forestry_df,Intensive_forestry_df)
new_land_categories_index = ('Annual crops', 'Permanent Crops', 'Pasture', 'Urban', 'Extensive forestry', 'Intensive forestry')
for i in landuse_list :
    Land_aggregated_df = Land_aggregated_df.append(i)   #Appending Land_aggregated_df with each of the aggregated land use categories

Land_aggregated_df.reset_index()
Land_aggregated_df.set_axis(new_land_categories_index, inplace=True) #Updating the index row labels

#Combining the aggregated land use stressor categories with the disaggregated land use stressors, and the stressors for the other impact categories being analysed. This is the final compiled stressor matrix.
#Not necessary to add land stressors, but nice to have for future reference if required.

stressor_list = (climate_change_stressors,water_stressors,eutrophication_stressors,land_stressors)
exiobase3.satellite.S = Land_aggregated_df  #Full_stressor_list = All required stressors (aggregated and disaggregated) for footprint calculations
for i in stressor_list :
    exiobase3.satellite.S = exiobase3.satellite.S.append(i)

S = pd.DataFrame(exiobase3.satellite.S)
S.to_csv('S_check.csv')

##################################################################################################################################################################################################################

'''Segregating required stressors from S_Y tables in exactly the same fashion as what was completed above for the S tables'''

##################################################################################################################################################################################################################

S_Y = pd.DataFrame(exiobase3.satellite.S_Y)
land_stressors_S_Y = pd.DataFrame(S_Y.iloc[[446,447,448,449,450,451,452,453,454,455,456,457,458,459, 461,462,463,464,465],:])  #Seperation of land use categories using indexing. Rows obtained from csv file
water_stressors_S_Y = pd.DataFrame(S_Y.iloc[923:1026])  #Blue water consumption stressor rows
climate_change_stressors_S_Y = pd.DataFrame(S_Y.iloc[[23,24,25,67,68,69,70,71,72,73,74,92,93,426,427,429,435,437,438]]) #Global warming stressor rows
eutrophication_stressors_S_Y = pd.DataFrame(S_Y.iloc[[432,433,434,440,443]]) #Marine and Fresh eutrophication

#Combining the aggregated land use stressor categories with the disaggregated land use stressors, and the stressors for the other impact categories being analysed. This is the final compiled stressor matrix.

#Aggregation of exiobase land use categories to LC-IMPACT categories_S_Y

Annual_crop_df_S_Y = pd.DataFrame(land_stressors_S_Y.iloc[[0,1,2,3,4,5,6,7,8,9,10,12],:]).sum(0) #Aggregation of the annual crop categories in exiobase to the singular LC-IMPACT category for Land Use
Annual_crop_df_S_Y = pd.DataFrame(Annual_crop_df_S_Y).T #As python outputs a column vector for a sumation operation, the transpose function T is used to return the annual crop dataframe to it's original Dataframe index/column set up with countries and products as the column index and stressor as the row index.
Permanent_crop_df_S_Y = pd.DataFrame(land_stressors_S_Y.iloc[[11],:]).sum(0)  #Aggregation of permanent crop categories to LC-Impact land category
Permanent_crop_df_S_Y = pd.DataFrame(Permanent_crop_df_S_Y).T   #Transposing to original Dataframe layout.
Pasture_crop_df_S_Y = pd.DataFrame(land_stressors_S_Y.iloc[[14,15,16],:]).sum(0) #Aggregation of Pasture crop land use categories
Pasture_crop_df_S_Y = pd.DataFrame(Pasture_crop_df_S_Y).T
Urban_df_S_Y = pd.DataFrame(land_stressors_S_Y.iloc[[17],:]).sum(0) #Aggregation of Urban land use categories
Urban_df_S_Y = pd.DataFrame(Urban_df_S_Y).T
Intensive_forestry_df_S_Y = pd.DataFrame(land_stressors_S_Y.iloc[[13],:]).sum(0) #Aggregation of Intensive forestry land use stresors to LC-Impact category
Intensive_forestry_df_S_Y = pd.DataFrame(Intensive_forestry_df_S_Y).T
Extensive_forestry_df_S_Y = pd.DataFrame(land_stressors_S_Y.iloc[[18],:]).sum(0) #Aggregation of Intensive forestry land use stresors to LC-Impact
Extensive_forestry_df_S_Y = pd.DataFrame(Extensive_forestry_df_S_Y).T

#Re-creating a combined dataframe for the aggregated land use stressors_F_Y

Land_aggregated_df_S_Y = Annual_crop_df_S_Y
landuse_list = (Permanent_crop_df_S_Y,Pasture_crop_df_S_Y,Urban_df_S_Y,Extensive_forestry_df_S_Y,Intensive_forestry_df_S_Y)
new_land_categories_index = ('Annual crops', 'Permanent Crops', 'Pasture', 'Urban', 'Extensive forestry', 'Intensive forestry')
for i in landuse_list :
    Land_aggregated_df_S_Y = Land_aggregated_df_S_Y.append(i)   #Appending Land_aggregated_df with each of the aggregated land use categories

Land_aggregated_df_S_Y.reset_index()
Land_aggregated_df_S_Y.set_axis(new_land_categories_index, inplace=True) #Updating the index row labels

#Combining the aggregated land use stressor categories with the disaggregated land use stressors, and the stressors for the other impact categories being analysed. This is the final compiled stressor matrix for F_Y.

stressor_list_S_Y = (climate_change_stressors_S_Y,water_stressors_S_Y,eutrophication_stressors_S_Y,land_stressors_S_Y)
exiobase3.satellite.S_Y = Land_aggregated_df_S_Y  #Full_stressor_list = All required stressors (aggregated and disaggregated) for footprint calculations
for i in stressor_list_S_Y :
    exiobase3.satellite.S_Y = exiobase3.satellite.S_Y.append(i)

exiobase3.satellite.S_Y = pd.DataFrame(exiobase3.satellite.S_Y.loc[:,idx[:,'Final consumption expenditure by households']])  #Seggregating final consumer househould expenditure

S_Y = pd.DataFrame(exiobase3.satellite.S_Y)


##################################################################################################################################################################################################################

'''With a new Y table, S table and S_Y table, all other tables are reset to the co-efficients
    for the recalculation of new x,F,Z,M tables. Resetting of coefficients with pymrio resets all tables in EXIOBASE other than the
    A and L matrices'''


##################################################################################################################################################################################################################
exiobase3.reset_all_to_coefficients()
print(exiobase3.A) #9800x9800
print(exiobase3.L) #9800x9800
print(exiobase3.x) #0
print(exiobase3.satellite.F) #0
print(exiobase3.Z) #0
print(exiobase3.satellite.M) #0
exiobase3.Y = pd.DataFrame(Y)  #Setting Y tables to Y tables formed in the first section of the code
exiobase3.satellite.S = pd.DataFrame(S) #Setting S tables to S tables formed in the second section of the code
exiobase3.satellite.S_Y = pd.DataFrame(S_Y) #Setting S_Y tables to S_Y tables formed in third section of the code
Y = exiobase3.Y
exiobase3.x = pymrio.calc_x_from_L(exiobase3.L, exiobase3.Y.sum(1)) #Using PYMRIO functionality to calculate x from L and Y tables
exiobase3.Z = pymrio.calc_Z(exiobase3.A, exiobase3.x) #Using PYMRIO functionality to calculate Z from A and x tables


exiobase3.satellite.F_Y = pd.DataFrame(pymrio.calc_F_Y(exiobase3.satellite.S_Y,exiobase3.Y.sum(0)))
print(exiobase3.satellite.F_Y.shape)
exiobase3.satellite.F = pd.DataFrame(pymrio.calc_F(exiobase3.satellite.S,exiobase3.x))
print(exiobase3.satellite.S)
print(exiobase3.satellite.F)
print(exiobase3.satellite.F_Y)
print(exiobase3.satellite.F.shape)
exiobase3.M = pd.DataFrame(pymrio.calc_M(exiobase3.satellite.S,exiobase3.L))
exiobase3.satellite.F.to_csv('F_test.csv')
exiobase3.x.to_csv('x_test.csv')

##################################################################################################################################################################################################################

'''Following re-calc of all relevant tables, the PYMRIO calc_accounts function is used
to calculate pressure footprint accounts D_cba, D_pba, D_imp and D_exp. The function returns a tupple where
new_accounts[0] = D_cba, new_accounts[1] = D_pba, new_accounts[2] = D_imp, new_accounts[3] = D_exp.'''

##################################################################################################################################################################################################################
new_accounts = pymrio.calc_accounts(exiobase3.satellite.S, exiobase3.L, exiobase3.Y, nr_sectors=200)
exiobase3.satellite.D_cba = new_accounts[0]
print(exiobase3.satellite.D_cba.shape)
exiobase3.satellite.D_pba = new_accounts[1]
print(exiobase3.satellite.D_pba.shape)

exiobase3.satellite.D_imp = new_accounts[2]
print(exiobase3.satellite.D_imp.shape)

exiobase3.satellite.D_exp = new_accounts[3]
print(exiobase3.satellite.D_exp.shape)

exiobase3.save_all('C:/Users/Cillian/PycharmProjects/MRIO_project_Ver_01/Exiobase3 folder/Exiobase3 coefficient tables (latest)')

print(exiobase3.meta)


